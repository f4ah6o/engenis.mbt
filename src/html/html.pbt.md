<!-- aletheia:begin -->
# Property-Based Test Targets for html

> Auto-generated by Aletheia - MoonBit PBT Tool

## Overview

- **Source**: `/Users/fu2hito/src/moonbit/engenis.mbt-pbt/src/html`
- **Generated**: 2026-01-16
- **Patterns Detected**: 11

## Round-Trip Targets

- `Swap::to_string` <-> `Swap::from_string`

## Invariant Targets

- `add` (LengthIncreasing)
- `hx_swap` (LengthPreserving)
- `hx_delete` (LengthDecreasing)
- `hx_swap_safe` (LengthPreserving)

<!-- aletheia:end -->

---

# Property-Based Tests

## Package: html

### prop_swap_roundtrip

Round-trip property: Swap::to_string followed by Swap::from_string returns original value

```mbt check
///|
test "prop_swap_roundtrip" {
  let swaps = [
    InnerHTML,
    OuterHTML,
    BeforeBegin,
    AfterBegin,
    BeforeEnd,
    AfterEnd,
    Delete,
    None,
  ]
  for i = 0; i < swaps.length(); i = i + 1 {
    let original = swaps[i]
    let str = original.to_string()
    let parsed = Swap::from_string(str)
    assert_eq(parsed, original, msg="round-trip failed for " + str)
  }
}
```

### prop_swap_from_string_unknown_returns_none

Property: Swap::from_string returns None for unknown values

```mbt check
///|
test "prop_swap_from_string_unknown_returns_none" {
  let unknown = Swap::from_string("unknown_swap_value")
  assert_eq(unknown, None)
}
```

### prop_attrvalue_to_string_preserves_content

Property: AttrValue::to_string preserves the underlying value

```mbt check
///|
test "prop_attrvalue_to_string_preserves_content" {
  let s = AttrValue::Str("hello")
  assert_eq(s.to_string(), "hello")

  let b_true = AttrValue::Bool(true)
  assert_eq(b_true.to_string(), "true")
  let b_false = AttrValue::Bool(false)
  assert_eq(b_false.to_string(), "false")

  let i = AttrValue::Int(42)
  assert_eq(i.to_string(), "42")

  let n = AttrValue::None
  assert_eq(n.to_string(), "")
}
```

### prop_attrs_add_increases_length

Property: Attrs::add increases the number of attributes

```mbt check
///|
test "prop_attrs_add_increases_length" {
  let empty = Attrs::new()
  assert_eq(empty.attrs.length(), 0)

  let with_one = empty.add("key1", AttrValue::Str("val1"))
  assert_eq(with_one.attrs.length(), 1)

  let with_two = with_one.add("key2", AttrValue::Str("val2"))
  assert_eq(with_two.attrs.length(), 2)

  let with_duplicate = with_two.add("key1", AttrValue::Str("new_val"))
  assert_eq(with_duplicate.attrs.length(), 3)
}
```

### prop_hx_swap_preserves_length

Property: Attrs::hx_swap replaces existing hx-swap attribute (length-preserving)

```mbt check
///|
test "prop_hx_swap_preserves_length" {
  let attrs1 = Attrs::new()
  assert_eq(attrs1.attrs.length(), 0)

  let attrs2 = attrs1.hx_swap("innerHTML")
  assert_eq(attrs2.attrs.length(), 1)

  let attrs3 = attrs2.hx_swap("outerHTML")
  assert_eq(attrs3.attrs.length(), 1)
}
```

### prop_hx_swap_safe_preserves_length

Property: Attrs::hx_swap_safe replaces existing hx-swap attribute (length-preserving)

```mbt check
///|
test "prop_hx_swap_safe_preserves_length" {
  let attrs1 = Attrs::new()
  assert_eq(attrs1.attrs.length(), 0)

  let attrs2 = attrs1.hx_swap_safe(InnerHTML)
  assert_eq(attrs2.attrs.length(), 1)

  let attrs3 = attrs2.hx_swap_safe(OuterHTML)
  assert_eq(attrs3.attrs.length(), 1)
}
```

### prop_hx_delete_reduces_length

Property: Adding hx_delete increases length

```mbt check
///|
test "prop_hx_delete_reduces_length" {
  let attrs1 = Attrs::new()
  assert_eq(attrs1.attrs.length(), 0)

  let attrs2 = attrs1.hx_delete("/delete")
  assert_eq(attrs2.attrs.length(), 1)
}
```

### prop_html_render_escapes_special_chars

Property: Html::render escapes HTML special characters

```mbt check
///|
test "prop_html_render_escapes_special_chars" {
  let html = div().text("<test>").render()
  assert_true(html.contains("&lt;test&gt;"), msg="should escape < and >")
  assert_true(!html.contains("<test>"), msg="should not contain raw <test>")
}
```

### prop_html_render_escapes_ampersand

Property: Html::render escapes ampersand character

```mbt check
///|
test "prop_html_render_escapes_ampersand" {
  let html = div().text("a & b").render()
  assert_true(html.contains("a &amp; b"), msg="should escape &")
}
```

### prop_html_render_escapes_quotes

Property: Html::render escapes quote characters in text content

```mbt check
///|
test "prop_html_render_escapes_quotes" {
  let html = div().text("\"quoted\"").render()
  assert_true(html.contains("&quot;quoted&quot;"), msg="should escape quotes")
}
```

### prop_html_render_preserves_utf8

Property: Html::render preserves UTF-8 characters

```mbt check
///|
test "prop_html_render_preserves_utf8" {
  let ja = div().text("こんにちは").render()
  assert_true(ja.contains("こんにちは"), msg="should preserve Japanese")

  let mixed = div().text("<日本語>&").render()
  assert_true(mixed.contains("日本語"), msg="should preserve Japanese in mixed")
  assert_true(mixed.contains("&lt;日本語&gt;"), msg="should escape tags with Japanese")
}
```

### prop_attrs_merge_prefer_takes_precedence

Property: Attrs::merge prefers attributes from first argument

```mbt check
///|
test "prop_attrs_merge_prefer_takes_precedence" {
  let fallback = Attrs::new().add("class", AttrValue::Str("fallback"))
  let prefer = Attrs::new().add("class", AttrValue::Str("prefer"))

  let merged = Attrs::merge(prefer, fallback)

  // Should have 1 attribute (prefer's class wins)
  assert_eq(merged.attrs.length(), 1)
  assert_eq(merged.attrs[0].0, "class")
  match merged.attrs[0].1 {
    Str(s) => assert_eq(s, "prefer")
    _ => assert_true(false, msg="should be Str variant")
  }
}
```

### prop_attrs_merge_combines_unique_keys

Property: Attrs::merge combines unique attributes from both

```mbt check
///|
test "prop_attrs_merge_combines_unique_keys" {
  let fallback = Attrs::new().add("class", AttrValue::Str("fallback"))
  let prefer = Attrs::new().add("id", AttrValue::Str("unique"))

  let merged = Attrs::merge(prefer, fallback)

  // Should have 2 attributes
  assert_eq(merged.attrs.length(), 2)
}
```

### prop_trigger_mod_to_string_formats_correctly

Property: TriggerMod::to_string produces correct modifier syntax

```mbt check
///|
test "prop_trigger_mod_to_string_formats_correctly" {
  assert_eq(Once.to_string(), "once")
  assert_eq(Changed.to_string(), "changed")
  assert_eq(Delay(100).to_string(), "delay:100ms")
  assert_eq(Throttle(200).to_string(), "throttle:200ms")
  assert_eq(From("#form").to_string(), "from:#form")
  assert_eq(Target("#btn").to_string(), "target:#btn")
}
```

### prop_trigger_to_string_combines_mods

Property: Trigger::to_string combines event name with modifiers

```mbt check
///|
test "prop_trigger_to_string_combines_mods" {
  let trigger = EventWithMods("click", [Once, From("#btn")])
  let result = trigger.to_string()
  assert_true(result.contains("click"), msg="should contain event name")
  assert_true(result.contains("once"), msg="should contain once modifier")
  assert_true(result.contains("from:#btn"), msg="should contain from modifier")
}
```
